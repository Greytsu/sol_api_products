// Code generated by SQLBoiler 4.14.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// BeBundleElement is an object representing the database table.
type BeBundleElement struct {
	BeID         int       `boil:"be_id" json:"be_id" toml:"be_id" yaml:"be_id"`
	BeCompanyID  int       `boil:"be_company_id" json:"be_company_id" toml:"be_company_id" yaml:"be_company_id"`
	BeFKBundleID null.Int  `boil:"be_fk_bundle_id" json:"be_fk_bundle_id,omitempty" toml:"be_fk_bundle_id" yaml:"be_fk_bundle_id,omitempty"`
	BeFKOptionID null.Int  `boil:"be_fk_option_id" json:"be_fk_option_id,omitempty" toml:"be_fk_option_id" yaml:"be_fk_option_id,omitempty"`
	BeQuantity   int       `boil:"be_quantity" json:"be_quantity" toml:"be_quantity" yaml:"be_quantity"`
	BeCreateTime time.Time `boil:"be_create_time" json:"be_create_time" toml:"be_create_time" yaml:"be_create_time"`
	BeUpdateTime time.Time `boil:"be_update_time" json:"be_update_time" toml:"be_update_time" yaml:"be_update_time"`
	BeDeleted    null.Bool `boil:"be_deleted" json:"be_deleted,omitempty" toml:"be_deleted" yaml:"be_deleted,omitempty"`

	R *beBundleElementR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L beBundleElementL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var BeBundleElementColumns = struct {
	BeID         string
	BeCompanyID  string
	BeFKBundleID string
	BeFKOptionID string
	BeQuantity   string
	BeCreateTime string
	BeUpdateTime string
	BeDeleted    string
}{
	BeID:         "be_id",
	BeCompanyID:  "be_company_id",
	BeFKBundleID: "be_fk_bundle_id",
	BeFKOptionID: "be_fk_option_id",
	BeQuantity:   "be_quantity",
	BeCreateTime: "be_create_time",
	BeUpdateTime: "be_update_time",
	BeDeleted:    "be_deleted",
}

var BeBundleElementTableColumns = struct {
	BeID         string
	BeCompanyID  string
	BeFKBundleID string
	BeFKOptionID string
	BeQuantity   string
	BeCreateTime string
	BeUpdateTime string
	BeDeleted    string
}{
	BeID:         "be_bundle_element.be_id",
	BeCompanyID:  "be_bundle_element.be_company_id",
	BeFKBundleID: "be_bundle_element.be_fk_bundle_id",
	BeFKOptionID: "be_bundle_element.be_fk_option_id",
	BeQuantity:   "be_bundle_element.be_quantity",
	BeCreateTime: "be_bundle_element.be_create_time",
	BeUpdateTime: "be_bundle_element.be_update_time",
	BeDeleted:    "be_bundle_element.be_deleted",
}

// Generated where

type whereHelperint struct{ field string }

func (w whereHelperint) EQ(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint) NEQ(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint) LT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint) LTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint) GT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint) GTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint) IN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint) NIN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpernull_Int struct{ field string }

func (w whereHelpernull_Int) EQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int) NEQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int) LT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int) LTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int) GT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int) GTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Int) IN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Int) NIN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Int) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpertime_Time struct{ field string }

func (w whereHelpertime_Time) EQ(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertime_Time) NEQ(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertime_Time) LT(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertime_Time) LTE(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertime_Time) GT(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertime_Time) GTE(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpernull_Bool struct{ field string }

func (w whereHelpernull_Bool) EQ(x null.Bool) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Bool) NEQ(x null.Bool) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Bool) LT(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Bool) LTE(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Bool) GT(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Bool) GTE(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_Bool) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Bool) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var BeBundleElementWhere = struct {
	BeID         whereHelperint
	BeCompanyID  whereHelperint
	BeFKBundleID whereHelpernull_Int
	BeFKOptionID whereHelpernull_Int
	BeQuantity   whereHelperint
	BeCreateTime whereHelpertime_Time
	BeUpdateTime whereHelpertime_Time
	BeDeleted    whereHelpernull_Bool
}{
	BeID:         whereHelperint{field: "[products].[be_bundle_element].[be_id]"},
	BeCompanyID:  whereHelperint{field: "[products].[be_bundle_element].[be_company_id]"},
	BeFKBundleID: whereHelpernull_Int{field: "[products].[be_bundle_element].[be_fk_bundle_id]"},
	BeFKOptionID: whereHelpernull_Int{field: "[products].[be_bundle_element].[be_fk_option_id]"},
	BeQuantity:   whereHelperint{field: "[products].[be_bundle_element].[be_quantity]"},
	BeCreateTime: whereHelpertime_Time{field: "[products].[be_bundle_element].[be_create_time]"},
	BeUpdateTime: whereHelpertime_Time{field: "[products].[be_bundle_element].[be_update_time]"},
	BeDeleted:    whereHelpernull_Bool{field: "[products].[be_bundle_element].[be_deleted]"},
}

// BeBundleElementRels is where relationship names are stored.
var BeBundleElementRels = struct {
	BeFKBundle string
	BeFKOption string
}{
	BeFKBundle: "BeFKBundle",
	BeFKOption: "BeFKOption",
}

// beBundleElementR is where relationships are stored.
type beBundleElementR struct {
	BeFKBundle *BuBundle `boil:"BeFKBundle" json:"BeFKBundle" toml:"BeFKBundle" yaml:"BeFKBundle"`
	BeFKOption *OpOption `boil:"BeFKOption" json:"BeFKOption" toml:"BeFKOption" yaml:"BeFKOption"`
}

// NewStruct creates a new relationship struct
func (*beBundleElementR) NewStruct() *beBundleElementR {
	return &beBundleElementR{}
}

func (r *beBundleElementR) GetBeFKBundle() *BuBundle {
	if r == nil {
		return nil
	}
	return r.BeFKBundle
}

func (r *beBundleElementR) GetBeFKOption() *OpOption {
	if r == nil {
		return nil
	}
	return r.BeFKOption
}

// beBundleElementL is where Load methods for each relationship are stored.
type beBundleElementL struct{}

var (
	beBundleElementAllColumns            = []string{"be_id", "be_company_id", "be_fk_bundle_id", "be_fk_option_id", "be_quantity", "be_create_time", "be_update_time", "be_deleted"}
	beBundleElementColumnsWithoutDefault = []string{"be_company_id", "be_fk_bundle_id", "be_fk_option_id", "be_quantity"}
	beBundleElementColumnsWithDefault    = []string{"be_id", "be_create_time", "be_update_time", "be_deleted"}
	beBundleElementPrimaryKeyColumns     = []string{"be_id"}
	beBundleElementGeneratedColumns      = []string{"be_id"}
)

type (
	// BeBundleElementSlice is an alias for a slice of pointers to BeBundleElement.
	// This should almost always be used instead of []BeBundleElement.
	BeBundleElementSlice []*BeBundleElement
	// BeBundleElementHook is the signature for custom BeBundleElement hook methods
	BeBundleElementHook func(context.Context, boil.ContextExecutor, *BeBundleElement) error

	beBundleElementQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	beBundleElementType                 = reflect.TypeOf(&BeBundleElement{})
	beBundleElementMapping              = queries.MakeStructMapping(beBundleElementType)
	beBundleElementPrimaryKeyMapping, _ = queries.BindMapping(beBundleElementType, beBundleElementMapping, beBundleElementPrimaryKeyColumns)
	beBundleElementInsertCacheMut       sync.RWMutex
	beBundleElementInsertCache          = make(map[string]insertCache)
	beBundleElementUpdateCacheMut       sync.RWMutex
	beBundleElementUpdateCache          = make(map[string]updateCache)
	beBundleElementUpsertCacheMut       sync.RWMutex
	beBundleElementUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var beBundleElementAfterSelectHooks []BeBundleElementHook

var beBundleElementBeforeInsertHooks []BeBundleElementHook
var beBundleElementAfterInsertHooks []BeBundleElementHook

var beBundleElementBeforeUpdateHooks []BeBundleElementHook
var beBundleElementAfterUpdateHooks []BeBundleElementHook

var beBundleElementBeforeDeleteHooks []BeBundleElementHook
var beBundleElementAfterDeleteHooks []BeBundleElementHook

var beBundleElementBeforeUpsertHooks []BeBundleElementHook
var beBundleElementAfterUpsertHooks []BeBundleElementHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *BeBundleElement) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range beBundleElementAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *BeBundleElement) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range beBundleElementBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *BeBundleElement) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range beBundleElementAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *BeBundleElement) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range beBundleElementBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *BeBundleElement) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range beBundleElementAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *BeBundleElement) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range beBundleElementBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *BeBundleElement) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range beBundleElementAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *BeBundleElement) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range beBundleElementBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *BeBundleElement) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range beBundleElementAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddBeBundleElementHook registers your hook function for all future operations.
func AddBeBundleElementHook(hookPoint boil.HookPoint, beBundleElementHook BeBundleElementHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		beBundleElementAfterSelectHooks = append(beBundleElementAfterSelectHooks, beBundleElementHook)
	case boil.BeforeInsertHook:
		beBundleElementBeforeInsertHooks = append(beBundleElementBeforeInsertHooks, beBundleElementHook)
	case boil.AfterInsertHook:
		beBundleElementAfterInsertHooks = append(beBundleElementAfterInsertHooks, beBundleElementHook)
	case boil.BeforeUpdateHook:
		beBundleElementBeforeUpdateHooks = append(beBundleElementBeforeUpdateHooks, beBundleElementHook)
	case boil.AfterUpdateHook:
		beBundleElementAfterUpdateHooks = append(beBundleElementAfterUpdateHooks, beBundleElementHook)
	case boil.BeforeDeleteHook:
		beBundleElementBeforeDeleteHooks = append(beBundleElementBeforeDeleteHooks, beBundleElementHook)
	case boil.AfterDeleteHook:
		beBundleElementAfterDeleteHooks = append(beBundleElementAfterDeleteHooks, beBundleElementHook)
	case boil.BeforeUpsertHook:
		beBundleElementBeforeUpsertHooks = append(beBundleElementBeforeUpsertHooks, beBundleElementHook)
	case boil.AfterUpsertHook:
		beBundleElementAfterUpsertHooks = append(beBundleElementAfterUpsertHooks, beBundleElementHook)
	}
}

// One returns a single beBundleElement record from the query.
func (q beBundleElementQuery) One(ctx context.Context, exec boil.ContextExecutor) (*BeBundleElement, error) {
	o := &BeBundleElement{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for be_bundle_element")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all BeBundleElement records from the query.
func (q beBundleElementQuery) All(ctx context.Context, exec boil.ContextExecutor) (BeBundleElementSlice, error) {
	var o []*BeBundleElement

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to BeBundleElement slice")
	}

	if len(beBundleElementAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all BeBundleElement records in the query.
func (q beBundleElementQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count be_bundle_element rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q beBundleElementQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if be_bundle_element exists")
	}

	return count > 0, nil
}

// BeFKBundle pointed to by the foreign key.
func (o *BeBundleElement) BeFKBundle(mods ...qm.QueryMod) buBundleQuery {
	queryMods := []qm.QueryMod{
		qm.Where("[bu_id] = ?", o.BeFKBundleID),
	}

	queryMods = append(queryMods, mods...)

	return BuBundles(queryMods...)
}

// BeFKOption pointed to by the foreign key.
func (o *BeBundleElement) BeFKOption(mods ...qm.QueryMod) opOptionQuery {
	queryMods := []qm.QueryMod{
		qm.Where("[op_id] = ?", o.BeFKOptionID),
	}

	queryMods = append(queryMods, mods...)

	return OpOptions(queryMods...)
}

// LoadBeFKBundle allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (beBundleElementL) LoadBeFKBundle(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBeBundleElement interface{}, mods queries.Applicator) error {
	var slice []*BeBundleElement
	var object *BeBundleElement

	if singular {
		var ok bool
		object, ok = maybeBeBundleElement.(*BeBundleElement)
		if !ok {
			object = new(BeBundleElement)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeBeBundleElement)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeBeBundleElement))
			}
		}
	} else {
		s, ok := maybeBeBundleElement.(*[]*BeBundleElement)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeBeBundleElement)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeBeBundleElement))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &beBundleElementR{}
		}
		if !queries.IsNil(object.BeFKBundleID) {
			args = append(args, object.BeFKBundleID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &beBundleElementR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.BeFKBundleID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.BeFKBundleID) {
				args = append(args, obj.BeFKBundleID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`products.bu_bundle`),
		qm.WhereIn(`products.bu_bundle.bu_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load BuBundle")
	}

	var resultSlice []*BuBundle
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice BuBundle")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for bu_bundle")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for bu_bundle")
	}

	if len(buBundleAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BeFKBundle = foreign
		if foreign.R == nil {
			foreign.R = &buBundleR{}
		}
		foreign.R.BeFKBundleBeBundleElements = append(foreign.R.BeFKBundleBeBundleElements, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.BeFKBundleID, foreign.BuID) {
				local.R.BeFKBundle = foreign
				if foreign.R == nil {
					foreign.R = &buBundleR{}
				}
				foreign.R.BeFKBundleBeBundleElements = append(foreign.R.BeFKBundleBeBundleElements, local)
				break
			}
		}
	}

	return nil
}

// LoadBeFKOption allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (beBundleElementL) LoadBeFKOption(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBeBundleElement interface{}, mods queries.Applicator) error {
	var slice []*BeBundleElement
	var object *BeBundleElement

	if singular {
		var ok bool
		object, ok = maybeBeBundleElement.(*BeBundleElement)
		if !ok {
			object = new(BeBundleElement)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeBeBundleElement)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeBeBundleElement))
			}
		}
	} else {
		s, ok := maybeBeBundleElement.(*[]*BeBundleElement)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeBeBundleElement)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeBeBundleElement))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &beBundleElementR{}
		}
		if !queries.IsNil(object.BeFKOptionID) {
			args = append(args, object.BeFKOptionID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &beBundleElementR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.BeFKOptionID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.BeFKOptionID) {
				args = append(args, obj.BeFKOptionID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`products.op_option`),
		qm.WhereIn(`products.op_option.op_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load OpOption")
	}

	var resultSlice []*OpOption
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice OpOption")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for op_option")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for op_option")
	}

	if len(opOptionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BeFKOption = foreign
		if foreign.R == nil {
			foreign.R = &opOptionR{}
		}
		foreign.R.BeFKOptionBeBundleElements = append(foreign.R.BeFKOptionBeBundleElements, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.BeFKOptionID, foreign.OpID) {
				local.R.BeFKOption = foreign
				if foreign.R == nil {
					foreign.R = &opOptionR{}
				}
				foreign.R.BeFKOptionBeBundleElements = append(foreign.R.BeFKOptionBeBundleElements, local)
				break
			}
		}
	}

	return nil
}

// SetBeFKBundle of the beBundleElement to the related item.
// Sets o.R.BeFKBundle to related.
// Adds o to related.R.BeFKBundleBeBundleElements.
func (o *BeBundleElement) SetBeFKBundle(ctx context.Context, exec boil.ContextExecutor, insert bool, related *BuBundle) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE [products].[be_bundle_element] SET %s WHERE %s",
		strmangle.SetParamNames("[", "]", 1, []string{"be_fk_bundle_id"}),
		strmangle.WhereClause("[", "]", 2, beBundleElementPrimaryKeyColumns),
	)
	values := []interface{}{related.BuID, o.BeID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.BeFKBundleID, related.BuID)
	if o.R == nil {
		o.R = &beBundleElementR{
			BeFKBundle: related,
		}
	} else {
		o.R.BeFKBundle = related
	}

	if related.R == nil {
		related.R = &buBundleR{
			BeFKBundleBeBundleElements: BeBundleElementSlice{o},
		}
	} else {
		related.R.BeFKBundleBeBundleElements = append(related.R.BeFKBundleBeBundleElements, o)
	}

	return nil
}

// RemoveBeFKBundle relationship.
// Sets o.R.BeFKBundle to nil.
// Removes o from all passed in related items' relationships struct.
func (o *BeBundleElement) RemoveBeFKBundle(ctx context.Context, exec boil.ContextExecutor, related *BuBundle) error {
	var err error

	queries.SetScanner(&o.BeFKBundleID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("be_fk_bundle_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.BeFKBundle = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.BeFKBundleBeBundleElements {
		if queries.Equal(o.BeFKBundleID, ri.BeFKBundleID) {
			continue
		}

		ln := len(related.R.BeFKBundleBeBundleElements)
		if ln > 1 && i < ln-1 {
			related.R.BeFKBundleBeBundleElements[i] = related.R.BeFKBundleBeBundleElements[ln-1]
		}
		related.R.BeFKBundleBeBundleElements = related.R.BeFKBundleBeBundleElements[:ln-1]
		break
	}
	return nil
}

// SetBeFKOption of the beBundleElement to the related item.
// Sets o.R.BeFKOption to related.
// Adds o to related.R.BeFKOptionBeBundleElements.
func (o *BeBundleElement) SetBeFKOption(ctx context.Context, exec boil.ContextExecutor, insert bool, related *OpOption) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE [products].[be_bundle_element] SET %s WHERE %s",
		strmangle.SetParamNames("[", "]", 1, []string{"be_fk_option_id"}),
		strmangle.WhereClause("[", "]", 2, beBundleElementPrimaryKeyColumns),
	)
	values := []interface{}{related.OpID, o.BeID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.BeFKOptionID, related.OpID)
	if o.R == nil {
		o.R = &beBundleElementR{
			BeFKOption: related,
		}
	} else {
		o.R.BeFKOption = related
	}

	if related.R == nil {
		related.R = &opOptionR{
			BeFKOptionBeBundleElements: BeBundleElementSlice{o},
		}
	} else {
		related.R.BeFKOptionBeBundleElements = append(related.R.BeFKOptionBeBundleElements, o)
	}

	return nil
}

// RemoveBeFKOption relationship.
// Sets o.R.BeFKOption to nil.
// Removes o from all passed in related items' relationships struct.
func (o *BeBundleElement) RemoveBeFKOption(ctx context.Context, exec boil.ContextExecutor, related *OpOption) error {
	var err error

	queries.SetScanner(&o.BeFKOptionID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("be_fk_option_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.BeFKOption = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.BeFKOptionBeBundleElements {
		if queries.Equal(o.BeFKOptionID, ri.BeFKOptionID) {
			continue
		}

		ln := len(related.R.BeFKOptionBeBundleElements)
		if ln > 1 && i < ln-1 {
			related.R.BeFKOptionBeBundleElements[i] = related.R.BeFKOptionBeBundleElements[ln-1]
		}
		related.R.BeFKOptionBeBundleElements = related.R.BeFKOptionBeBundleElements[:ln-1]
		break
	}
	return nil
}

// BeBundleElements retrieves all the records using an executor.
func BeBundleElements(mods ...qm.QueryMod) beBundleElementQuery {
	mods = append(mods, qm.From("[products].[be_bundle_element]"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"[products].[be_bundle_element].*"})
	}

	return beBundleElementQuery{q}
}

// FindBeBundleElement retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindBeBundleElement(ctx context.Context, exec boil.ContextExecutor, beID int, selectCols ...string) (*BeBundleElement, error) {
	beBundleElementObj := &BeBundleElement{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from [products].[be_bundle_element] where [be_id]=$1", sel,
	)

	q := queries.Raw(query, beID)

	err := q.Bind(ctx, exec, beBundleElementObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from be_bundle_element")
	}

	if err = beBundleElementObj.doAfterSelectHooks(ctx, exec); err != nil {
		return beBundleElementObj, err
	}

	return beBundleElementObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *BeBundleElement) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no be_bundle_element provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(beBundleElementColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	beBundleElementInsertCacheMut.RLock()
	cache, cached := beBundleElementInsertCache[key]
	beBundleElementInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			beBundleElementAllColumns,
			beBundleElementColumnsWithDefault,
			beBundleElementColumnsWithoutDefault,
			nzDefaults,
		)
		wl = strmangle.SetComplement(wl, beBundleElementGeneratedColumns)

		cache.valueMapping, err = queries.BindMapping(beBundleElementType, beBundleElementMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(beBundleElementType, beBundleElementMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO [products].[be_bundle_element] ([%s]) %%sVALUES (%s)%%s", strings.Join(wl, "],["), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO [products].[be_bundle_element] %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryOutput = fmt.Sprintf("OUTPUT INSERTED.[%s] ", strings.Join(returnColumns, "],INSERTED.["))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into be_bundle_element")
	}

	if !cached {
		beBundleElementInsertCacheMut.Lock()
		beBundleElementInsertCache[key] = cache
		beBundleElementInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the BeBundleElement.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *BeBundleElement) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	beBundleElementUpdateCacheMut.RLock()
	cache, cached := beBundleElementUpdateCache[key]
	beBundleElementUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			beBundleElementAllColumns,
			beBundleElementPrimaryKeyColumns,
		)
		wl = strmangle.SetComplement(wl, beBundleElementGeneratedColumns)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update be_bundle_element, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE [products].[be_bundle_element] SET %s WHERE %s",
			strmangle.SetParamNames("[", "]", 1, wl),
			strmangle.WhereClause("[", "]", len(wl)+1, beBundleElementPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(beBundleElementType, beBundleElementMapping, append(wl, beBundleElementPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update be_bundle_element row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for be_bundle_element")
	}

	if !cached {
		beBundleElementUpdateCacheMut.Lock()
		beBundleElementUpdateCache[key] = cache
		beBundleElementUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q beBundleElementQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for be_bundle_element")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for be_bundle_element")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o BeBundleElementSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), beBundleElementPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE [products].[be_bundle_element] SET %s WHERE %s",
		strmangle.SetParamNames("[", "]", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, beBundleElementPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in beBundleElement slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all beBundleElement")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
func (o *BeBundleElement) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no be_bundle_element provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(beBundleElementColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	beBundleElementUpsertCacheMut.RLock()
	cache, cached := beBundleElementUpsertCache[key]
	beBundleElementUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			beBundleElementAllColumns,
			beBundleElementColumnsWithDefault,
			beBundleElementColumnsWithoutDefault,
			nzDefaults,
		)

		insert = strmangle.SetComplement(insert, beBundleElementGeneratedColumns)

		for i, v := range insert {
			if strmangle.ContainsAny(beBundleElementPrimaryKeyColumns, v) && strmangle.ContainsAny(beBundleElementColumnsWithDefault, v) {
				insert = append(insert[:i], insert[i+1:]...)
			}
		}
		if len(insert) == 0 {
			return errors.New("models: unable to upsert be_bundle_element, could not build insert column list")
		}

		update := updateColumns.UpdateColumnSet(
			beBundleElementAllColumns,
			beBundleElementPrimaryKeyColumns,
		)

		insert = strmangle.SetComplement(insert, beBundleElementGeneratedColumns)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert be_bundle_element, could not build update column list")
		}

		cache.query = buildUpsertQueryMSSQL(dialect, "[products].[be_bundle_element]", beBundleElementPrimaryKeyColumns, update, insert, ret)

		whitelist := make([]string, len(beBundleElementPrimaryKeyColumns))
		copy(whitelist, beBundleElementPrimaryKeyColumns)
		whitelist = append(whitelist, update...)
		whitelist = append(whitelist, insert...)

		cache.valueMapping, err = queries.BindMapping(beBundleElementType, beBundleElementMapping, whitelist)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(beBundleElementType, beBundleElementMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // MSSQL doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert be_bundle_element")
	}

	if !cached {
		beBundleElementUpsertCacheMut.Lock()
		beBundleElementUpsertCache[key] = cache
		beBundleElementUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single BeBundleElement record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *BeBundleElement) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no BeBundleElement provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), beBundleElementPrimaryKeyMapping)
	sql := "DELETE FROM [products].[be_bundle_element] WHERE [be_id]=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from be_bundle_element")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for be_bundle_element")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q beBundleElementQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no beBundleElementQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from be_bundle_element")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for be_bundle_element")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o BeBundleElementSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(beBundleElementBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), beBundleElementPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM [products].[be_bundle_element] WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, beBundleElementPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from beBundleElement slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for be_bundle_element")
	}

	if len(beBundleElementAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *BeBundleElement) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindBeBundleElement(ctx, exec, o.BeID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *BeBundleElementSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := BeBundleElementSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), beBundleElementPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT [products].[be_bundle_element].* FROM [products].[be_bundle_element] WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, beBundleElementPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in BeBundleElementSlice")
	}

	*o = slice

	return nil
}

// BeBundleElementExists checks if the BeBundleElement row exists.
func BeBundleElementExists(ctx context.Context, exec boil.ContextExecutor, beID int) (bool, error) {
	var exists bool
	sql := "select case when exists(select top(1) 1 from [products].[be_bundle_element] where [be_id]=$1) then 1 else 0 end"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, beID)
	}
	row := exec.QueryRowContext(ctx, sql, beID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if be_bundle_element exists")
	}

	return exists, nil
}

// Exists checks if the BeBundleElement row exists.
func (o *BeBundleElement) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return BeBundleElementExists(ctx, exec, o.BeID)
}
