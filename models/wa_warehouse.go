// Code generated by SQLBoiler 4.14.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// WaWarehouse is an object representing the database table.
type WaWarehouse struct {
	WaID         int         `boil:"wa_id" json:"wa_id" toml:"wa_id" yaml:"wa_id"`
	WaCompanyID  int         `boil:"wa_company_id" json:"wa_company_id" toml:"wa_company_id" yaml:"wa_company_id"`
	WaName       string      `boil:"wa_name" json:"wa_name" toml:"wa_name" yaml:"wa_name"`
	WaAddress    string      `boil:"wa_address" json:"wa_address" toml:"wa_address" yaml:"wa_address"`
	WaComplement null.String `boil:"wa_complement" json:"wa_complement,omitempty" toml:"wa_complement" yaml:"wa_complement,omitempty"`
	WaZip        string      `boil:"wa_zip" json:"wa_zip" toml:"wa_zip" yaml:"wa_zip"`
	WaCity       string      `boil:"wa_city" json:"wa_city" toml:"wa_city" yaml:"wa_city"`
	WaRegion     string      `boil:"wa_region" json:"wa_region" toml:"wa_region" yaml:"wa_region"`
	WaCountry    string      `boil:"wa_country" json:"wa_country" toml:"wa_country" yaml:"wa_country"`
	WaManager    string      `boil:"wa_manager" json:"wa_manager" toml:"wa_manager" yaml:"wa_manager"`
	WaPhone      string      `boil:"wa_phone" json:"wa_phone" toml:"wa_phone" yaml:"wa_phone"`
	WaEmail      string      `boil:"wa_email" json:"wa_email" toml:"wa_email" yaml:"wa_email"`
	WaCreateTime time.Time   `boil:"wa_create_time" json:"wa_create_time" toml:"wa_create_time" yaml:"wa_create_time"`
	WaUpdateTime time.Time   `boil:"wa_update_time" json:"wa_update_time" toml:"wa_update_time" yaml:"wa_update_time"`
	WaDeleted    null.Bool   `boil:"wa_deleted" json:"wa_deleted,omitempty" toml:"wa_deleted" yaml:"wa_deleted,omitempty"`

	R *waWarehouseR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L waWarehouseL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var WaWarehouseColumns = struct {
	WaID         string
	WaCompanyID  string
	WaName       string
	WaAddress    string
	WaComplement string
	WaZip        string
	WaCity       string
	WaRegion     string
	WaCountry    string
	WaManager    string
	WaPhone      string
	WaEmail      string
	WaCreateTime string
	WaUpdateTime string
	WaDeleted    string
}{
	WaID:         "wa_id",
	WaCompanyID:  "wa_company_id",
	WaName:       "wa_name",
	WaAddress:    "wa_address",
	WaComplement: "wa_complement",
	WaZip:        "wa_zip",
	WaCity:       "wa_city",
	WaRegion:     "wa_region",
	WaCountry:    "wa_country",
	WaManager:    "wa_manager",
	WaPhone:      "wa_phone",
	WaEmail:      "wa_email",
	WaCreateTime: "wa_create_time",
	WaUpdateTime: "wa_update_time",
	WaDeleted:    "wa_deleted",
}

var WaWarehouseTableColumns = struct {
	WaID         string
	WaCompanyID  string
	WaName       string
	WaAddress    string
	WaComplement string
	WaZip        string
	WaCity       string
	WaRegion     string
	WaCountry    string
	WaManager    string
	WaPhone      string
	WaEmail      string
	WaCreateTime string
	WaUpdateTime string
	WaDeleted    string
}{
	WaID:         "wa_warehouse.wa_id",
	WaCompanyID:  "wa_warehouse.wa_company_id",
	WaName:       "wa_warehouse.wa_name",
	WaAddress:    "wa_warehouse.wa_address",
	WaComplement: "wa_warehouse.wa_complement",
	WaZip:        "wa_warehouse.wa_zip",
	WaCity:       "wa_warehouse.wa_city",
	WaRegion:     "wa_warehouse.wa_region",
	WaCountry:    "wa_warehouse.wa_country",
	WaManager:    "wa_warehouse.wa_manager",
	WaPhone:      "wa_warehouse.wa_phone",
	WaEmail:      "wa_warehouse.wa_email",
	WaCreateTime: "wa_warehouse.wa_create_time",
	WaUpdateTime: "wa_warehouse.wa_update_time",
	WaDeleted:    "wa_warehouse.wa_deleted",
}

// Generated where

type whereHelpernull_String struct{ field string }

func (w whereHelpernull_String) EQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_String) NEQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_String) LT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_String) LTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_String) GT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_String) GTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_String) IN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_String) NIN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_String) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_String) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var WaWarehouseWhere = struct {
	WaID         whereHelperint
	WaCompanyID  whereHelperint
	WaName       whereHelperstring
	WaAddress    whereHelperstring
	WaComplement whereHelpernull_String
	WaZip        whereHelperstring
	WaCity       whereHelperstring
	WaRegion     whereHelperstring
	WaCountry    whereHelperstring
	WaManager    whereHelperstring
	WaPhone      whereHelperstring
	WaEmail      whereHelperstring
	WaCreateTime whereHelpertime_Time
	WaUpdateTime whereHelpertime_Time
	WaDeleted    whereHelpernull_Bool
}{
	WaID:         whereHelperint{field: "[products].[wa_warehouse].[wa_id]"},
	WaCompanyID:  whereHelperint{field: "[products].[wa_warehouse].[wa_company_id]"},
	WaName:       whereHelperstring{field: "[products].[wa_warehouse].[wa_name]"},
	WaAddress:    whereHelperstring{field: "[products].[wa_warehouse].[wa_address]"},
	WaComplement: whereHelpernull_String{field: "[products].[wa_warehouse].[wa_complement]"},
	WaZip:        whereHelperstring{field: "[products].[wa_warehouse].[wa_zip]"},
	WaCity:       whereHelperstring{field: "[products].[wa_warehouse].[wa_city]"},
	WaRegion:     whereHelperstring{field: "[products].[wa_warehouse].[wa_region]"},
	WaCountry:    whereHelperstring{field: "[products].[wa_warehouse].[wa_country]"},
	WaManager:    whereHelperstring{field: "[products].[wa_warehouse].[wa_manager]"},
	WaPhone:      whereHelperstring{field: "[products].[wa_warehouse].[wa_phone]"},
	WaEmail:      whereHelperstring{field: "[products].[wa_warehouse].[wa_email]"},
	WaCreateTime: whereHelpertime_Time{field: "[products].[wa_warehouse].[wa_create_time]"},
	WaUpdateTime: whereHelpertime_Time{field: "[products].[wa_warehouse].[wa_update_time]"},
	WaDeleted:    whereHelpernull_Bool{field: "[products].[wa_warehouse].[wa_deleted]"},
}

// WaWarehouseRels is where relationship names are stored.
var WaWarehouseRels = struct {
	STFKWarehouseSTStocks string
}{
	STFKWarehouseSTStocks: "STFKWarehouseSTStocks",
}

// waWarehouseR is where relationships are stored.
type waWarehouseR struct {
	STFKWarehouseSTStocks STStockSlice `boil:"STFKWarehouseSTStocks" json:"STFKWarehouseSTStocks" toml:"STFKWarehouseSTStocks" yaml:"STFKWarehouseSTStocks"`
}

// NewStruct creates a new relationship struct
func (*waWarehouseR) NewStruct() *waWarehouseR {
	return &waWarehouseR{}
}

func (r *waWarehouseR) GetSTFKWarehouseSTStocks() STStockSlice {
	if r == nil {
		return nil
	}
	return r.STFKWarehouseSTStocks
}

// waWarehouseL is where Load methods for each relationship are stored.
type waWarehouseL struct{}

var (
	waWarehouseAllColumns            = []string{"wa_id", "wa_company_id", "wa_name", "wa_address", "wa_complement", "wa_zip", "wa_city", "wa_region", "wa_country", "wa_manager", "wa_phone", "wa_email", "wa_create_time", "wa_update_time", "wa_deleted"}
	waWarehouseColumnsWithoutDefault = []string{"wa_company_id", "wa_name", "wa_address", "wa_complement", "wa_zip", "wa_city", "wa_region", "wa_country", "wa_manager", "wa_phone", "wa_email"}
	waWarehouseColumnsWithDefault    = []string{"wa_id", "wa_create_time", "wa_update_time", "wa_deleted"}
	waWarehousePrimaryKeyColumns     = []string{"wa_id"}
	waWarehouseGeneratedColumns      = []string{"wa_id"}
)

type (
	// WaWarehouseSlice is an alias for a slice of pointers to WaWarehouse.
	// This should almost always be used instead of []WaWarehouse.
	WaWarehouseSlice []*WaWarehouse
	// WaWarehouseHook is the signature for custom WaWarehouse hook methods
	WaWarehouseHook func(context.Context, boil.ContextExecutor, *WaWarehouse) error

	waWarehouseQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	waWarehouseType                 = reflect.TypeOf(&WaWarehouse{})
	waWarehouseMapping              = queries.MakeStructMapping(waWarehouseType)
	waWarehousePrimaryKeyMapping, _ = queries.BindMapping(waWarehouseType, waWarehouseMapping, waWarehousePrimaryKeyColumns)
	waWarehouseInsertCacheMut       sync.RWMutex
	waWarehouseInsertCache          = make(map[string]insertCache)
	waWarehouseUpdateCacheMut       sync.RWMutex
	waWarehouseUpdateCache          = make(map[string]updateCache)
	waWarehouseUpsertCacheMut       sync.RWMutex
	waWarehouseUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var waWarehouseAfterSelectHooks []WaWarehouseHook

var waWarehouseBeforeInsertHooks []WaWarehouseHook
var waWarehouseAfterInsertHooks []WaWarehouseHook

var waWarehouseBeforeUpdateHooks []WaWarehouseHook
var waWarehouseAfterUpdateHooks []WaWarehouseHook

var waWarehouseBeforeDeleteHooks []WaWarehouseHook
var waWarehouseAfterDeleteHooks []WaWarehouseHook

var waWarehouseBeforeUpsertHooks []WaWarehouseHook
var waWarehouseAfterUpsertHooks []WaWarehouseHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *WaWarehouse) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range waWarehouseAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *WaWarehouse) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range waWarehouseBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *WaWarehouse) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range waWarehouseAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *WaWarehouse) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range waWarehouseBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *WaWarehouse) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range waWarehouseAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *WaWarehouse) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range waWarehouseBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *WaWarehouse) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range waWarehouseAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *WaWarehouse) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range waWarehouseBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *WaWarehouse) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range waWarehouseAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddWaWarehouseHook registers your hook function for all future operations.
func AddWaWarehouseHook(hookPoint boil.HookPoint, waWarehouseHook WaWarehouseHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		waWarehouseAfterSelectHooks = append(waWarehouseAfterSelectHooks, waWarehouseHook)
	case boil.BeforeInsertHook:
		waWarehouseBeforeInsertHooks = append(waWarehouseBeforeInsertHooks, waWarehouseHook)
	case boil.AfterInsertHook:
		waWarehouseAfterInsertHooks = append(waWarehouseAfterInsertHooks, waWarehouseHook)
	case boil.BeforeUpdateHook:
		waWarehouseBeforeUpdateHooks = append(waWarehouseBeforeUpdateHooks, waWarehouseHook)
	case boil.AfterUpdateHook:
		waWarehouseAfterUpdateHooks = append(waWarehouseAfterUpdateHooks, waWarehouseHook)
	case boil.BeforeDeleteHook:
		waWarehouseBeforeDeleteHooks = append(waWarehouseBeforeDeleteHooks, waWarehouseHook)
	case boil.AfterDeleteHook:
		waWarehouseAfterDeleteHooks = append(waWarehouseAfterDeleteHooks, waWarehouseHook)
	case boil.BeforeUpsertHook:
		waWarehouseBeforeUpsertHooks = append(waWarehouseBeforeUpsertHooks, waWarehouseHook)
	case boil.AfterUpsertHook:
		waWarehouseAfterUpsertHooks = append(waWarehouseAfterUpsertHooks, waWarehouseHook)
	}
}

// One returns a single waWarehouse record from the query.
func (q waWarehouseQuery) One(ctx context.Context, exec boil.ContextExecutor) (*WaWarehouse, error) {
	o := &WaWarehouse{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for wa_warehouse")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all WaWarehouse records from the query.
func (q waWarehouseQuery) All(ctx context.Context, exec boil.ContextExecutor) (WaWarehouseSlice, error) {
	var o []*WaWarehouse

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to WaWarehouse slice")
	}

	if len(waWarehouseAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all WaWarehouse records in the query.
func (q waWarehouseQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count wa_warehouse rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q waWarehouseQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if wa_warehouse exists")
	}

	return count > 0, nil
}

// STFKWarehouseSTStocks retrieves all the st_stock's STStocks with an executor via st_fk_warehouse_id column.
func (o *WaWarehouse) STFKWarehouseSTStocks(mods ...qm.QueryMod) stStockQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("[products].[st_stock].[st_fk_warehouse_id]=?", o.WaID),
	)

	return STStocks(queryMods...)
}

// LoadSTFKWarehouseSTStocks allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (waWarehouseL) LoadSTFKWarehouseSTStocks(ctx context.Context, e boil.ContextExecutor, singular bool, maybeWaWarehouse interface{}, mods queries.Applicator) error {
	var slice []*WaWarehouse
	var object *WaWarehouse

	if singular {
		var ok bool
		object, ok = maybeWaWarehouse.(*WaWarehouse)
		if !ok {
			object = new(WaWarehouse)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeWaWarehouse)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeWaWarehouse))
			}
		}
	} else {
		s, ok := maybeWaWarehouse.(*[]*WaWarehouse)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeWaWarehouse)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeWaWarehouse))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &waWarehouseR{}
		}
		args = append(args, object.WaID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &waWarehouseR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.WaID) {
					continue Outer
				}
			}

			args = append(args, obj.WaID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`products.st_stock`),
		qm.WhereIn(`products.st_stock.st_fk_warehouse_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load st_stock")
	}

	var resultSlice []*STStock
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice st_stock")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on st_stock")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for st_stock")
	}

	if len(stStockAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.STFKWarehouseSTStocks = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &stStockR{}
			}
			foreign.R.STFKWarehouse = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.WaID, foreign.STFKWarehouseID) {
				local.R.STFKWarehouseSTStocks = append(local.R.STFKWarehouseSTStocks, foreign)
				if foreign.R == nil {
					foreign.R = &stStockR{}
				}
				foreign.R.STFKWarehouse = local
				break
			}
		}
	}

	return nil
}

// AddSTFKWarehouseSTStocks adds the given related objects to the existing relationships
// of the wa_warehouse, optionally inserting them as new records.
// Appends related to o.R.STFKWarehouseSTStocks.
// Sets related.R.STFKWarehouse appropriately.
func (o *WaWarehouse) AddSTFKWarehouseSTStocks(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*STStock) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.STFKWarehouseID, o.WaID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE [products].[st_stock] SET %s WHERE %s",
				strmangle.SetParamNames("[", "]", 1, []string{"st_fk_warehouse_id"}),
				strmangle.WhereClause("[", "]", 2, stStockPrimaryKeyColumns),
			)
			values := []interface{}{o.WaID, rel.STID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.STFKWarehouseID, o.WaID)
		}
	}

	if o.R == nil {
		o.R = &waWarehouseR{
			STFKWarehouseSTStocks: related,
		}
	} else {
		o.R.STFKWarehouseSTStocks = append(o.R.STFKWarehouseSTStocks, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &stStockR{
				STFKWarehouse: o,
			}
		} else {
			rel.R.STFKWarehouse = o
		}
	}
	return nil
}

// SetSTFKWarehouseSTStocks removes all previously related items of the
// wa_warehouse replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.STFKWarehouse's STFKWarehouseSTStocks accordingly.
// Replaces o.R.STFKWarehouseSTStocks with related.
// Sets related.R.STFKWarehouse's STFKWarehouseSTStocks accordingly.
func (o *WaWarehouse) SetSTFKWarehouseSTStocks(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*STStock) error {
	query := "update [products].[st_stock] set [st_fk_warehouse_id] = null where [st_fk_warehouse_id] = $1"
	values := []interface{}{o.WaID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.STFKWarehouseSTStocks {
			queries.SetScanner(&rel.STFKWarehouseID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.STFKWarehouse = nil
		}
		o.R.STFKWarehouseSTStocks = nil
	}

	return o.AddSTFKWarehouseSTStocks(ctx, exec, insert, related...)
}

// RemoveSTFKWarehouseSTStocks relationships from objects passed in.
// Removes related items from R.STFKWarehouseSTStocks (uses pointer comparison, removal does not keep order)
// Sets related.R.STFKWarehouse.
func (o *WaWarehouse) RemoveSTFKWarehouseSTStocks(ctx context.Context, exec boil.ContextExecutor, related ...*STStock) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.STFKWarehouseID, nil)
		if rel.R != nil {
			rel.R.STFKWarehouse = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("st_fk_warehouse_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.STFKWarehouseSTStocks {
			if rel != ri {
				continue
			}

			ln := len(o.R.STFKWarehouseSTStocks)
			if ln > 1 && i < ln-1 {
				o.R.STFKWarehouseSTStocks[i] = o.R.STFKWarehouseSTStocks[ln-1]
			}
			o.R.STFKWarehouseSTStocks = o.R.STFKWarehouseSTStocks[:ln-1]
			break
		}
	}

	return nil
}

// WaWarehouses retrieves all the records using an executor.
func WaWarehouses(mods ...qm.QueryMod) waWarehouseQuery {
	mods = append(mods, qm.From("[products].[wa_warehouse]"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"[products].[wa_warehouse].*"})
	}

	return waWarehouseQuery{q}
}

// FindWaWarehouse retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindWaWarehouse(ctx context.Context, exec boil.ContextExecutor, waID int, selectCols ...string) (*WaWarehouse, error) {
	waWarehouseObj := &WaWarehouse{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from [products].[wa_warehouse] where [wa_id]=$1", sel,
	)

	q := queries.Raw(query, waID)

	err := q.Bind(ctx, exec, waWarehouseObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from wa_warehouse")
	}

	if err = waWarehouseObj.doAfterSelectHooks(ctx, exec); err != nil {
		return waWarehouseObj, err
	}

	return waWarehouseObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *WaWarehouse) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no wa_warehouse provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(waWarehouseColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	waWarehouseInsertCacheMut.RLock()
	cache, cached := waWarehouseInsertCache[key]
	waWarehouseInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			waWarehouseAllColumns,
			waWarehouseColumnsWithDefault,
			waWarehouseColumnsWithoutDefault,
			nzDefaults,
		)
		wl = strmangle.SetComplement(wl, waWarehouseGeneratedColumns)

		cache.valueMapping, err = queries.BindMapping(waWarehouseType, waWarehouseMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(waWarehouseType, waWarehouseMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO [products].[wa_warehouse] ([%s]) %%sVALUES (%s)%%s", strings.Join(wl, "],["), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO [products].[wa_warehouse] %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryOutput = fmt.Sprintf("OUTPUT INSERTED.[%s] ", strings.Join(returnColumns, "],INSERTED.["))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into wa_warehouse")
	}

	if !cached {
		waWarehouseInsertCacheMut.Lock()
		waWarehouseInsertCache[key] = cache
		waWarehouseInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the WaWarehouse.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *WaWarehouse) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	waWarehouseUpdateCacheMut.RLock()
	cache, cached := waWarehouseUpdateCache[key]
	waWarehouseUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			waWarehouseAllColumns,
			waWarehousePrimaryKeyColumns,
		)
		wl = strmangle.SetComplement(wl, waWarehouseGeneratedColumns)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update wa_warehouse, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE [products].[wa_warehouse] SET %s WHERE %s",
			strmangle.SetParamNames("[", "]", 1, wl),
			strmangle.WhereClause("[", "]", len(wl)+1, waWarehousePrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(waWarehouseType, waWarehouseMapping, append(wl, waWarehousePrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update wa_warehouse row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for wa_warehouse")
	}

	if !cached {
		waWarehouseUpdateCacheMut.Lock()
		waWarehouseUpdateCache[key] = cache
		waWarehouseUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q waWarehouseQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for wa_warehouse")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for wa_warehouse")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o WaWarehouseSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), waWarehousePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE [products].[wa_warehouse] SET %s WHERE %s",
		strmangle.SetParamNames("[", "]", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, waWarehousePrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in waWarehouse slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all waWarehouse")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
func (o *WaWarehouse) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no wa_warehouse provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(waWarehouseColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	waWarehouseUpsertCacheMut.RLock()
	cache, cached := waWarehouseUpsertCache[key]
	waWarehouseUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			waWarehouseAllColumns,
			waWarehouseColumnsWithDefault,
			waWarehouseColumnsWithoutDefault,
			nzDefaults,
		)

		insert = strmangle.SetComplement(insert, waWarehouseGeneratedColumns)

		for i, v := range insert {
			if strmangle.ContainsAny(waWarehousePrimaryKeyColumns, v) && strmangle.ContainsAny(waWarehouseColumnsWithDefault, v) {
				insert = append(insert[:i], insert[i+1:]...)
			}
		}
		if len(insert) == 0 {
			return errors.New("models: unable to upsert wa_warehouse, could not build insert column list")
		}

		update := updateColumns.UpdateColumnSet(
			waWarehouseAllColumns,
			waWarehousePrimaryKeyColumns,
		)

		insert = strmangle.SetComplement(insert, waWarehouseGeneratedColumns)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert wa_warehouse, could not build update column list")
		}

		cache.query = buildUpsertQueryMSSQL(dialect, "[products].[wa_warehouse]", waWarehousePrimaryKeyColumns, update, insert, ret)

		whitelist := make([]string, len(waWarehousePrimaryKeyColumns))
		copy(whitelist, waWarehousePrimaryKeyColumns)
		whitelist = append(whitelist, update...)
		whitelist = append(whitelist, insert...)

		cache.valueMapping, err = queries.BindMapping(waWarehouseType, waWarehouseMapping, whitelist)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(waWarehouseType, waWarehouseMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // MSSQL doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert wa_warehouse")
	}

	if !cached {
		waWarehouseUpsertCacheMut.Lock()
		waWarehouseUpsertCache[key] = cache
		waWarehouseUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single WaWarehouse record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *WaWarehouse) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no WaWarehouse provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), waWarehousePrimaryKeyMapping)
	sql := "DELETE FROM [products].[wa_warehouse] WHERE [wa_id]=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from wa_warehouse")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for wa_warehouse")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q waWarehouseQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no waWarehouseQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from wa_warehouse")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for wa_warehouse")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o WaWarehouseSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(waWarehouseBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), waWarehousePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM [products].[wa_warehouse] WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, waWarehousePrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from waWarehouse slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for wa_warehouse")
	}

	if len(waWarehouseAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *WaWarehouse) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindWaWarehouse(ctx, exec, o.WaID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *WaWarehouseSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := WaWarehouseSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), waWarehousePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT [products].[wa_warehouse].* FROM [products].[wa_warehouse] WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, waWarehousePrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in WaWarehouseSlice")
	}

	*o = slice

	return nil
}

// WaWarehouseExists checks if the WaWarehouse row exists.
func WaWarehouseExists(ctx context.Context, exec boil.ContextExecutor, waID int) (bool, error) {
	var exists bool
	sql := "select case when exists(select top(1) 1 from [products].[wa_warehouse] where [wa_id]=$1) then 1 else 0 end"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, waID)
	}
	row := exec.QueryRowContext(ctx, sql, waID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if wa_warehouse exists")
	}

	return exists, nil
}

// Exists checks if the WaWarehouse row exists.
func (o *WaWarehouse) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return WaWarehouseExists(ctx, exec, o.WaID)
}
